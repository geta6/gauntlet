// Generated by CoffeeScript 1.7.1
(function() {
  'use strict';
  var Adaptor, Gauntlet, http,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  http = require('http');

  Gauntlet = require('./gauntlet');

  Adaptor = (function(_super) {
    __extends(Adaptor, _super);

    function Adaptor() {
      if (typeof this.initialize === 'function') {
        this.initialize.apply(this, arguments);
      }
    }

    Adaptor.options = {
      hostname: 'localhost',
      port: '80',
      headers: {}
    };

    Adaptor.parse = function(value) {
      var reason;
      try {
        if (!value.length) {
          return null;
        }
        return JSON.parse(value);
      } catch (_error) {
        reason = _error;
        return reason;
      }
    };

    Adaptor.request = function(resolve, reject, key, options, senddata) {
      var body, k, parse, v, _base, _base1, _ref;
      if (options == null) {
        options = {};
      }
      if (senddata == null) {
        senddata = '';
      }
      body = '';
      parse = this.parse;
      this.options.headers = {};
      _ref = this.options;
      for (k in _ref) {
        if (!__hasProp.call(_ref, k)) continue;
        v = _ref[k];
        options[k] = v;
      }
      options.path || (options.path = "/" + key);
      (_base = options.headers)['Content-Type'] || (_base['Content-Type'] = 'application/json');
      (_base1 = options.headers)['Content-Length'] || (_base1['Content-Length'] = senddata.length);
      return http.request(options, function(res) {
        body = '';
        res.on('data', function(chunk) {
          return body += chunk;
        });
        return res.on('end', (function(_this) {
          return function() {
            resolve({
              status: res.statusCode,
              body: parse(body)
            });
            return _this.abort();
          };
        })(this));
      }).on('error', reject).on('timeout', function() {
        return reject(new Error('timeout'));
      }).end(senddata, 'utf-8');
    };

    Adaptor.exists = function(key, options) {
      if (options == null) {
        options = {};
      }
      return new Gauntlet.Promise((function(_this) {
        return function(resolve, reject) {
          options.method = 'HEAD';
          return _this.request(resolve, reject, key, options, '');
        };
      })(this));
    };

    Adaptor.select = function(key, options) {
      if (options == null) {
        options = {};
      }
      return new Gauntlet.Promise((function(_this) {
        return function(resolve, reject) {
          options.method = 'GET';
          return _this.request(resolve, reject, key, options, '');
        };
      })(this));
    };

    Adaptor.insert = function(key, value, options) {
      if (options == null) {
        options = {};
      }
      return new Gauntlet.Promise((function(_this) {
        return function(resolve, reject) {
          options.method = 'POST';
          return _this.request(resolve, reject, key, options, JSON.stringify(value));
        };
      })(this));
    };

    Adaptor["delete"] = function(key, options) {
      if (options == null) {
        options = {};
      }
      return new Gauntlet.Promise((function(_this) {
        return function(resolve, reject) {
          options.method = 'DELETE';
          return _this.request(resolve, reject, key, options, '');
        };
      })(this));
    };

    Adaptor.update = function(key, value, options) {
      if (options == null) {
        options = {};
      }
      return new Gauntlet.Promise((function(_this) {
        return function(resolve, reject) {
          options.method = 'PUT';
          return _this.request(resolve, reject, key, options, JSON.stringify(value));
        };
      })(this));
    };

    return Adaptor;

  })(Gauntlet.Events);

  module.exports = Adaptor;

}).call(this);
