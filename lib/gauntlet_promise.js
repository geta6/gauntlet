// Generated by CoffeeScript 1.7.1
(function() {
  'use strict';
  var Promise;

  Promise = (function() {
    var PENDING, REJECTED, RESOLVED, SEALED, async, invoker, subscribe, trigger, _ref;

    PENDING = void 0;

    SEALED = 0;

    RESOLVED = 1;

    REJECTED = 2;

    async = (function() {
      var flush, queue, schedule;
      queue = [];
      flush = function() {
        var tuple, _results;
        _results = [];
        while (tuple = queue.shift()) {
          _results.push(tuple[0](tuple[1]));
        }
        return _results;
      };
      schedule = (function() {
        if (typeof window === 'undefined') {
          return function() {
            return process.nextTick(flush);
          };
        }
        return function() {
          return setTimeout(flush, 0);
        };
      })();
      return function(callback, argument) {
        var length;
        length = queue.push([callback, argument]);
        schedule();
      };
    })();

    subscribe = (function() {
      return function(parent, child, onResolved, onRejected) {
        var length;
        length = parent.__subscribers.length;
        parent.__subscribers[length] = child;
        parent.__subscribers[length + RESOLVED] = onResolved;
        parent.__subscribers[length + REJECTED] = onRejected;
      };
    })();

    _ref = (function() {
      var fulfill, handle, invoker, publish, publishWithRejected, publishWithResolved, reject, resolve, trigger;
      handle = function(promise, value) {
        var next, ng, ok, reason, resolved, type;
        next = void 0;
        resolved = void 0;
        try {
          if (promise === value) {
            throw new TypeError('Promise callback cannot return itself');
          }
          type = typeof value;
          if ((type === 'function') || ((type === 'object') && (value !== null))) {
            next = value.then;
            if (typeof next === 'function') {
              ok = function(val) {
                if (resolved) {
                  return true;
                }
                resolved = true;
                if (value !== val) {
                  return resolve(promise, val);
                } else {
                  return fulfill(promise, val);
                }
              };
              ng = function(val) {
                if (resolved) {
                  return true;
                }
                resolved = true;
                return reject(promise, val);
              };
              next.call(value, ok, ng);
              return true;
            }
          }
        } catch (_error) {
          reason = _error;
          if (resolved) {
            return true;
          }
          reject(promise, reason);
          return true;
        }
        return false;
      };
      resolve = function(promise, value) {
        if (promise === value) {
          return fulfill(promise, value);
        } else if (!handle(promise, value)) {
          return fulfill(promise, value);
        }
      };
      fulfill = function(promise, value) {
        if (promise.__state !== PENDING) {
          return;
        }
        promise.__state = SEALED;
        promise.__detail = value;
        return async(publishWithResolved, promise);
      };
      reject = function(promise, reason) {
        if (promise.__state !== PENDING) {
          return;
        }
        promise.__state = SEALED;
        promise.__detail = reason;
        return async(publishWithRejected, promise);
      };
      publishWithResolved = function(promise) {
        return publish(promise, promise.__state = RESOLVED);
      };
      publishWithRejected = function(promise) {
        return publish(promise, promise.__state = REJECTED);
      };
      publish = function(promise, settled) {
        var child, detail, i, length, subscribers, _i, _ref;
        detail = promise.__detail;
        length = (subscribers = promise.__subscribers).length;
        for (i = _i = 0, _ref = subscribers.length / 3; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          child = subscribers[i * 3];
          trigger(settled, child, subscribers[i * 3 + settled], detail);
        }
        subscribers = promise.__subscribers = null;
      };
      trigger = function(settled, promise, callback, detail) {
        var error, failure, hasCallback, reason, success, value;
        value = void 0;
        reason = void 0;
        success = false;
        failure = false;
        if (hasCallback = typeof callback === 'function') {
          try {
            value = callback(detail);
            success = true;
          } catch (_error) {
            error = _error;
            reason = error;
            failure = true;
          }
        } else {
          value = detail;
          success = true;
        }
        if (handle(promise, value)) {
          return;
        }
        if (success && hasCallback) {
          return resolve(promise, value);
        }
        if (failure) {
          return reject(promise, reason);
        }
        if (settled === RESOLVED) {
          return resolve(promise, value);
        }
        if (settled === REJECTED) {
          return reject(promise, value);
        }
      };
      invoker = function(resolver, promise) {
        var promiseRejector, promiseResolver, reason;
        promiseResolver = function(value) {
          return resolve(promise, value);
        };
        promiseRejector = function(reason) {
          return reject(promise, reason);
        };
        try {
          return resolver(promiseResolver, promiseRejector);
        } catch (_error) {
          reason = _error;
          return promiseRejector(reason);
        }
      };
      return [trigger, invoker];
    })(), trigger = _ref[0], invoker = _ref[1];

    Promise.resolve = function(value) {
      if ((value != null) && (typeof value === 'object') && (value.constructor === this)) {
        return value;
      }
      return new this(function(resolve) {
        return resolve(value);
      });
    };

    Promise.reject = function(reason) {
      return new Promise(function(resolve, reject) {
        return reject(reason);
      });
    };

    Promise.all = function(promises) {
      if ((Object.prototype.toString.call(promises)) !== '[object Array]') {
        throw new TypeError('An array as the first argument required.');
      }
      return new Promise(function(resolve, reject) {
        var i, length, promise, resolveAll, resolveFactory, results, _i, _len;
        results = [];
        length = promises.length;
        if (length === 0) {
          return resolve([]);
        }
        resolveAll = function(index, value) {
          results[index] = value;
          if (--length === 0) {
            return resolve(results);
          }
        };
        resolveFactory = function(index) {
          return function(value) {
            return resolveAll(index, value);
          };
        };
        for (i = _i = 0, _len = promises.length; _i < _len; i = ++_i) {
          promise = promises[i];
          if (promise && typeof promise.then === 'function') {
            promise.then(resolveFactory(i), reject);
          } else {
            resolveAll(i, promise);
          }
        }
      });
    };

    Promise.race = function(promises) {
      if ((Object.prototype.toString.call(promises)) !== '[object Array]') {
        throw new TypeError('An array as the first argument required.');
      }
      return new Promise(function(resolve, reject) {
        var promise, results, _i, _len;
        results = [];
        for (_i = 0, _len = promises.length; _i < _len; _i++) {
          promise = promises[_i];
          if (promise && typeof promise.then === 'function') {
            promise.then(resolve, reject);
          } else {
            resolve(promise);
          }
        }
      });
    };

    Promise.prototype.__state = PENDING;

    Promise.prototype.__detail = void 0;

    Promise.prototype.__subscribers = void 0;

    function Promise(resolver) {
      if (typeof resolver !== 'function') {
        throw new TypeError('A function as the first argument required.');
      }
      if (!(this instanceof Promise)) {
        throw new TypeError('Cannot be called as a function.');
      }
      this.__subscribers = [];
      invoker(resolver, this);
    }

    Promise.prototype.then = function(onResolved, onRejected) {
      var callbacks, promise;
      promise = new this.constructor(function() {});
      if (this.__state) {
        callbacks = arguments;
        async((function(_this) {
          return function() {
            return trigger(_this.__state, promise, callbacks[_this.__state - 1], _this.__detail);
          };
        })(this));
      } else {
        subscribe(this, promise, onResolved, onRejected);
      }
      return promise;
    };

    Promise.prototype["catch"] = function(onRejected) {
      return this.then(null, onRejected);
    };

    return Promise;

  })();

  module.exports = Promise;

}).call(this);
