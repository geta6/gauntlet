(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  'use strict';
  var Gauntlet;

  Gauntlet = (function() {
    function Gauntlet() {}

    Gauntlet.version = '0.0.1';

    Gauntlet.Events = require('./gauntlet_events');

    Gauntlet.Promise = require('./gauntlet_promise');

    return Gauntlet;

  })();

  module.exports = Gauntlet;

}).call(this);

},{"./gauntlet_events":2,"./gauntlet_promise":3}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  'use strict';
  var Events;

  Events = (function() {
    function Events() {
      this.__events = {};
    }

    Events.prototype.listeners = function(event) {
      return Array.apply(this, this.__events[event] || []);
    };

    Events.prototype.trigger = function(event, a1, a2, a3, a4, a5) {
      var argument, argumentLength, callback, callbackLength, callbacks, i, _i, _j, _k, _len;
      if ((!this.__events) || (!this.__events[event])) {
        return false;
      }
      callbacks = this.__events[event];
      callback = callbacks[0];
      callbackLength = callbacks.length;
      argument = [];
      argumentLength = arguments.length;
      if (callbackLength === 1) {
        if (callback.__one) {
          this.off(event, callback);
        }
        switch (argumentLength) {
          case 1:
            callback.call(callback.__ctx || this);
            break;
          case 2:
            callback.call(callback.__ctx || this, a1);
            break;
          case 3:
            callback.call(callback.__ctx || this, a1, a2);
            break;
          case 4:
            callback.call(callback.__ctx || this, a1, a2, a3);
            break;
          case 5:
            callback.call(callback.__ctx || this, a1, a2, a3, a4);
            break;
          case 6:
            callback.call(callback.__ctx || this, a1, a2, a3, a4, a5);
            break;
          default:
            for (i = _i = 1; 1 <= argumentLength ? _i < argumentLength : _i > argumentLength; i = 1 <= argumentLength ? ++_i : --_i) {
              argument[i - 1] = arguments[i];
            }
            callback.apply(callback.__ctx || this, argument);
        }
      } else {
        for (i = _j = 1; 1 <= argumentLength ? _j < argumentLength : _j > argumentLength; i = 1 <= argumentLength ? ++_j : --_j) {
          argument[i - 1] = arguments[i];
        }
        for (_k = 0, _len = callbacks.length; _k < _len; _k++) {
          callback = callbacks[_k];
          if (callback.__one) {
            this.off(event, callback);
          }
          callback.apply(callback.__ctx || this, argument);
        }
      }
      return true;
    };

    Events.prototype.on = function(event, callback, context) {
      if (!this.__events) {
        this.__events = {};
      }
      if (!this.__events[event]) {
        this.__events[event] = [];
      }
      callback.__ctx = context;
      this.__events[event].push(callback);
      return this;
    };

    Events.prototype.once = function(event, callback, context) {
      callback.__one = true;
      return this.on(event, callback, context);
    };

    Events.prototype.off = function(event, callback, context) {
      var events, __callback, _i, _len, _ref;
      if (!this.__events) {
        return this;
      }
      if (callback) {
        if (!this.__events[event]) {
          return this;
        }
        events = [];
        _ref = this.__events[event];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          __callback = _ref[_i];
          if (__callback) {
            if (__callback !== callback || __callback.__ctx !== context) {
              events.push(__callback);
            }
          }
        }
        this.__events[event] = events.length ? events : null;
      } else {
        if (event) {
          this.__events[event] = null;
        } else {
          this.__events = {};
        }
      }
      return this;
    };

    return Events;

  })();

  module.exports = Events;

}).call(this);

},{}],3:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  'use strict';
  var Promise;

  Promise = (function() {
    var PENDING, REJECTED, RESOLVED, SEALED, async, invoker, subscribe, trigger, _ref;

    PENDING = void 0;

    SEALED = 0;

    RESOLVED = 1;

    REJECTED = 2;

    async = (function() {
      var flush, queue, schedule;
      queue = [];
      flush = function() {
        var tuple, _results;
        _results = [];
        while (tuple = queue.shift()) {
          _results.push(tuple[0](tuple[1]));
        }
        return _results;
      };
      schedule = (function() {
        if (typeof window === 'undefined') {
          return function() {
            return process.nextTick(flush);
          };
        }
        return function() {
          return setTimeout(flush, 0);
        };
      })();
      return function(callback, argument) {
        var length;
        length = queue.push([callback, argument]);
        schedule();
      };
    })();

    subscribe = (function() {
      return function(parent, child, onResolved, onRejected) {
        var length;
        length = parent.__subscribers.length;
        parent.__subscribers[length] = child;
        parent.__subscribers[length + RESOLVED] = onResolved;
        parent.__subscribers[length + REJECTED] = onRejected;
      };
    })();

    _ref = (function() {
      var fulfill, handle, invoker, publish, publishWithRejected, publishWithResolved, reject, resolve, trigger;
      handle = function(promise, value) {
        var next, ng, ok, reason, resolved, type;
        next = void 0;
        resolved = void 0;
        try {
          if (promise === value) {
            throw new TypeError('Promise callback cannot return itself');
          }
          type = typeof value;
          if ((type === 'function') || ((type === 'object') && (value !== null))) {
            next = value.then;
            if (typeof next === 'function') {
              ok = function(val) {
                if (resolved) {
                  return true;
                }
                resolved = true;
                if (value !== val) {
                  return resolve(promise, val);
                } else {
                  return fulfill(promise, val);
                }
              };
              ng = function(val) {
                if (resolved) {
                  return true;
                }
                resolved = true;
                return reject(promise, val);
              };
              next.call(value, ok, ng);
              return true;
            }
          }
        } catch (_error) {
          reason = _error;
          if (resolved) {
            return true;
          }
          reject(promise, reason);
          return true;
        }
        return false;
      };
      resolve = function(promise, value) {
        if (promise === value) {
          return fulfill(promise, value);
        } else if (!handle(promise, value)) {
          return fulfill(promise, value);
        }
      };
      fulfill = function(promise, value) {
        if (promise.__state !== PENDING) {
          return;
        }
        promise.__state = SEALED;
        promise.__detail = value;
        return async(publishWithResolved, promise);
      };
      reject = function(promise, reason) {
        if (promise.__state !== PENDING) {
          return;
        }
        promise.__state = SEALED;
        promise.__detail = reason;
        return async(publishWithRejected, promise);
      };
      publishWithResolved = function(promise) {
        return publish(promise, promise.__state = RESOLVED);
      };
      publishWithRejected = function(promise) {
        return publish(promise, promise.__state = REJECTED);
      };
      publish = function(promise, settled) {
        var child, detail, i, length, subscribers, _i, _ref;
        detail = promise.__detail;
        length = (subscribers = promise.__subscribers).length;
        for (i = _i = 0, _ref = subscribers.length / 3; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          child = subscribers[i * 3];
          trigger(settled, child, subscribers[i * 3 + settled], detail);
        }
        subscribers = promise.__subscribers = null;
      };
      trigger = function(settled, promise, callback, detail) {
        var error, failure, hasCallback, reason, success, value;
        value = void 0;
        reason = void 0;
        success = false;
        failure = false;
        if (hasCallback = typeof callback === 'function') {
          try {
            value = callback(detail);
            success = true;
          } catch (_error) {
            error = _error;
            reason = error;
            failure = true;
          }
        } else {
          value = detail;
          success = true;
        }
        if (handle(promise, value)) {
          return;
        }
        if (success && hasCallback) {
          return resolve(promise, value);
        }
        if (failure) {
          return reject(promise, reason);
        }
        if (settled === RESOLVED) {
          return resolve(promise, value);
        }
        if (settled === REJECTED) {
          return reject(promise, value);
        }
      };
      invoker = function(resolver, promise) {
        var promiseRejector, promiseResolver, reason;
        promiseResolver = function(value) {
          return resolve(promise, value);
        };
        promiseRejector = function(reason) {
          return reject(promise, reason);
        };
        try {
          return resolver(promiseResolver, promiseRejector);
        } catch (_error) {
          reason = _error;
          return promiseRejector(reason);
        }
      };
      return [trigger, invoker];
    })(), trigger = _ref[0], invoker = _ref[1];

    Promise.resolve = function(value) {
      if ((value != null) && (typeof value === 'object') && (value.constructor === this)) {
        return value;
      }
      return new this(function(resolve) {
        return resolve(value);
      });
    };

    Promise.reject = function(reason) {
      return new Promise(function(resolve, reject) {
        return reject(reason);
      });
    };

    Promise.all = function(promises) {
      if ((Object.prototype.toString.call(promises)) !== '[object Array]') {
        throw new TypeError('An array as the first argument required.');
      }
      return new Promise(function(resolve, reject) {
        var i, length, promise, resolveAll, resolveFactory, results, _i, _len;
        results = [];
        length = promises.length;
        if (length === 0) {
          return resolve([]);
        }
        resolveAll = function(index, value) {
          results[index] = value;
          if (--length === 0) {
            return resolve(results);
          }
        };
        resolveFactory = function(index) {
          return function(value) {
            return resolveAll(index, value);
          };
        };
        for (i = _i = 0, _len = promises.length; _i < _len; i = ++_i) {
          promise = promises[i];
          if (promise && typeof promise.then === 'function') {
            promise.then(resolveFactory(i), reject);
          } else {
            resolveAll(i, promise);
          }
        }
      });
    };

    Promise.race = function(promises) {
      if ((Object.prototype.toString.call(promises)) !== '[object Array]') {
        throw new TypeError('An array as the first argument required.');
      }
      return new Promise(function(resolve, reject) {
        var promise, results, _i, _len;
        results = [];
        for (_i = 0, _len = promises.length; _i < _len; _i++) {
          promise = promises[_i];
          if (promise && typeof promise.then === 'function') {
            promise.then(resolve, reject);
          } else {
            resolve(promise);
          }
        }
      });
    };

    Promise.prototype.__state = PENDING;

    Promise.prototype.__detail = void 0;

    Promise.prototype.__subscribers = void 0;

    function Promise(resolver) {
      if (typeof resolver !== 'function') {
        throw new TypeError('A function as the first argument required.');
      }
      if (!(this instanceof Promise)) {
        throw new TypeError('Cannot be called as a function.');
      }
      this.__subscribers = [];
      invoker(resolver, this);
    }

    Promise.prototype.then = function(onResolved, onRejected) {
      var callbacks, promise;
      promise = new this.constructor(function() {});
      if (this.__state) {
        callbacks = arguments;
        async((function(_this) {
          return function() {
            return trigger(_this.__state, promise, callbacks[_this.__state - 1], _this.__detail);
          };
        })(this));
      } else {
        subscribe(this, promise, onResolved, onRejected);
      }
      return promise;
    };

    Promise.prototype["catch"] = function(onRejected) {
      return this.then(null, onRejected);
    };

    return Promise;

  })();

  module.exports = Promise;

}).call(this);

}).call(this,require("FWaASH"))
},{"FWaASH":4}],4:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}]},{},[1])